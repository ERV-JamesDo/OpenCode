I was introduced to Spring quite later in my software engineering career. I began my coding days in the workplace with Java Server Faces, as many would know it with its acronym, JSF. JSF is a powerful MVC (model-view-controller) Java standard technology used mainly for building component-based and event-driven web interfaces using the simple concept of beans and XHTML pages. A bean in JSF can both be a controller and a model. There is no pre-defined standard in the framework to distinguish between what a model bean is and a controller bean. In fact, JSF has left that decision to the architects and developers. Views are well defined as XHTML pages. XHTML is nothing but HTML with XML in it. XHTML pages allow for the creation of new components that can be reused across your project.

In most cases, businesses who make use of the JSF framework often pre-define an additional abstraction layer to help them to easily define the differences between what a controller bean is and a model bean - including to control their behaviours. This flexibility can also open holes for bad design paradigms which can prevent the application from scalability. Once you start working with JSF you will learn that there are certainly missing features you wish came out of the box, which is where Spring comes in.

JSF and Spring are good in their own unique ways. I like JSF for its great flexibility to build reusable web components and to easily define a standard format for templating a common structure of your web interfaces. On the other hand, JSF is not so great with managing bean and is not as powerful as Spring. Spring is yet one of the best frameworks to use for managing your beans and it makes use of the concept of dependency injection.

In this article, I am going to merge the best parts of these two giant Java MVC frameworks for building web applications by integrating JSF with Spring Boot. The role that JSF will harness is to build rich web components and to define a common standard in which my web interface will be structured. Spring will do the rest of the work - to manage my controllers, models, services, repositories (or data access objects) etc.
<h2>Getting our hands dirty</h2>
Now, let's get started with a simple tutorial.

&nbsp;

Firstly, we will create a new Spring Boot application using the <a href="https://start.spring.io/" target="_blank" rel="noopener noreferrer">Spring Initializr</a> tool online. Once you've connected to the Spring Initializr online:
<ul>
 	<li>choose to create a Maven Project</li>
 	<li>choose Java as your programming language</li>
 	<li>At the time of this article, the version of choice was 2.1.4</li>
 	<li>Enter your desired group ID and Artifact ID and any other details you wish to fill</li>
</ul>
<a href="https://tsepomaleka.com/wp-content/uploads/2019/04/spring-initialzr.png"><img class="aligncenter wp-image-630 size-full" src="https://tsepomaleka.com/wp-content/uploads/2019/04/spring-initialzr.png" alt="" width="896" height="928" /></a>

&nbsp;

We will now then select the dependencies to include in our Spring Boot project. For the purpose of this article, we will need only Spring Web MVC and the Embedded Apache Tomcat Server - this comes as a single dependency on Spring Boot.

<a href="https://tsepomaleka.com/wp-content/uploads/2019/04/spring-initialzr-2.png"><img class="aligncenter size-full wp-image-631" src="https://tsepomaleka.com/wp-content/uploads/2019/04/spring-initialzr-2.png" alt="" width="952" height="474" /></a>Once you've selected this dependency, go ahead and click the 'Generate Project' button. This action will create a Maven project and zip it before the download. Head over to the Downloads folder, decompress and copy the root Maven project to our desired workspace.
<h3>Importing the Maven project</h3>
For this tutorial, we will be using IntelliJ IDEA to create a new project, import the Maven module and to further write our code.

From IntelliJ IDEA, create a new Empty Project:

[su_carousel source="media: 632,633" link="lightbox" height="200" items="2"]

Once created, we import the Maven project into the project by navigating to the POM file in our file system. This may take a while as it will be resolving dependencies before the project loads the new module into view.

&nbsp;

Once we've done so, we can have a look at the POM file - it should look more or less the same.

[code language="xml" light="true"]

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

   <modelVersion>4.0.0</modelVersion>

   <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-parent</artifactId>
      <version>2.1.4.RELEASE</version>
      <relativePath/> <!-- lookup parent from repository -->
   </parent>

   <groupId>com.tsepomaleka</groupId>
   <artifactId>integrating-spring-and-jsf</artifactId>
   <version>0.0.1-SNAPSHOT</version>
   <name>Integrating Spring and JSF</name>
   <description>A Spring Boot Project to integrate Spring with JSF</description>

   <properties>
      <java.version>1.8</java.version>
   </properties>

   <dependencies>

      <dependency>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-web</artifactId>
      </dependency>

      <dependency>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-test</artifactId>
         <scope>test</scope>
      </dependency>

   </dependencies>

   <build>
      <plugins>
         <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
         </plugin>
      </plugins>
   </build>

</project>

[/code]

<h3>Adding the JoinFaces dependencies</h3>
Now, the next step is to add the JoinFaces dependencies. <a href="https://github.com/joinfaces/joinfaces" target="_blank" rel="noopener noreferrer">JoinFaces</a> is a community project that enables JSF usage in your Spring Boot application by automatically configuring all the JSF libraries you will need to get going, without much fuss. In our POM file, we will add a dependency for integrating JSF into our Spring Boot application. Your POM file should now look like this:

[code language="xml" light="true"]
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

   <modelVersion>4.0.0</modelVersion>

   <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-parent</artifactId>
      <version>2.1.4.RELEASE</version>
      <relativePath/> <!-- lookup parent from repository -->
   </parent>

   <groupId>com.tsepomaleka</groupId>
   <artifactId>integrating-spring-and-jsf</artifactId>
   <version>0.0.1-SNAPSHOT</version>
   <name>Integrating Spring and JSF</name>
   <description>A Spring Boot Project to integrate Spring with JSF</description>

   <properties>
      <java.version>1.8</java.version>
      <!-- 1. Define the property for the JoinFaces version -->
      <joinfaces.version>4.0.1</joinfaces.version>
   </properties>

   <dependencies>

      <dependency>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-web</artifactId>
      </dependency>

      <!-- 2. Add the JoinFaces Starter dependency -->

      <dependency>
         <groupId>org.joinfaces</groupId>
         <artifactId>jsf-spring-boot-starter</artifactId>
      </dependency>

      <dependency>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-test</artifactId>
         <scope>test</scope>
      </dependency>

   </dependencies>

   <!-- 3. The lastly, ddd this dependency management section in you POM file -->

   <dependencyManagement>
      <dependencies>
         <dependency>
            <groupId>org.joinfaces</groupId>
            <artifactId>joinfaces-dependencies</artifactId>
            <version>${joinfaces.version}</version>
            <type>pom</type>
            <scope>import</scope>
         </dependency>
      </dependencies>
   </dependencyManagement>

   <build>
      <plugins>
         <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
         </plugin>
      </plugins>
   </build>

</project>
[/code]

<h3>Configuring some application properties</h3>
Then we will head over to our <strong>application.properties</strong> file under the resources folder in our project and make these two entries. One is to set the server port to 5000 (or any other port you desire, but if you do not specify this property, Spring Boot will automatically use port 8080 - so this property is optional if you still want to use port 8080).

Then we will also turn off Thymeleaf in our application - this is to let Spring know that we will not be using the templating engine in our web pages and therefore it should not enable it.

[code language="properties" light="true"]

# the embedded application server config
server.port=5000
# thymeleaf templating engine config
spring.thymeleaf.enabled=false

[/code]

Now, you can build your project with test and if you don't get any errors, you're still good to go. Now, let's proceed.
<h3>Creating our service</h3>
For this tutorial, we will be creating a simple web page that takes in the year, a month and a day of the month and determines which day of the week it is. Firstly, we create a service that will perform the core logic to resolve a date to what day of the week it is, as a String type.

We create an interface to define the contract for this service:

[code language="java" light="true"]

public interface DayOfWeekResolverService
{
  String determineDayOfWeek(int year, int month, int dayOfMonth);
}

[/code]

Then we write the implementation for this service contract:

[code language="java" light="true"]

@Service
public class DayOfWeekResolverServiceImpl implements DayOfWeekResolverService
{
  @Override
  public String determineDayOfWeek(int year, int month, int dayOfMonth)
  {
    LocalDate resolvedLocalDate = LocalDate.of(year, month, dayOfMonth);
    return convertToDayOfWeekName(resolvedLocalDate.getDayOfWeek());
  }

  private String convertToDayOfWeekName(DayOfWeek dayOfWeek)
  {
    return dayOfWeek.getDisplayName(TextStyle.FULL, Locale.getDefault());
  }

}

[/code]

<h3>Creating form and action beans</h3>
We then create a model bean - which we will define as a form bean, by name conversion. In this example, form beans are models that hold on to the data that will be passed from the web page to the controller. These form beans will be managed by Spring and not JSF. In order to let Spring know that it should manage this bean, we should annotate it with @Component annotation. Then we need to define the scope of the form bean. For the purpose of this tutorial, our form beans will preferably be defined in the session scope, therefore, we use @SessionScope annotation.

[code language="java" light="true"]

@Component
@SessionScope
public class DayOfWeekResolverForm implements Serializable
{
  private int year;
  private int month;
  private int dayOfMonth;

  private String dayOfWeek;

  public int getYear()
  {
    return year;
  }

  public void setYear(int year)
  {
    this.year = year;
  }

  public int getMonth()
  {
    return month;
  }

  public void setMonth(int month)
  {
    this.month = month;
  }

  public int getDayOfMonth()
  {
    return dayOfMonth;
  }

  public void setDayOfMonth(int dayOfMonth)
  {
    this.dayOfMonth = dayOfMonth;
  }

  public String getDayOfWeek()
  {
    return dayOfWeek;
  }

  public void setDayOfWeek(String dayOfWeek)
  {
    this.dayOfWeek = dayOfWeek;
  }
}

[/code]

Then we move over to create a controller bean. This type of bean is an action bean - by name conversion only. This will become a standard for defining controller beans that perform the actual logic and are normally composed of our form beans. Our action beans will be also managed by Spring, therefore, we annotate our action beans with @Component. Then since our action beans do not carry any state or data, we will rather have them scoped for the current request they are needed for, so we annotate our action beans with @RequestScope.

We will also wire the service we created earlier to resolve a date to a day of the week.

[code language="java" light="true"]

@Component
@RequestScope
public class DayOfWeekResolverAction implements Serializable
{
  private final DayOfWeekResolverForm dayOfWeekResolverForm;
  private final DayOfWeekResolverService dayOfWeekResolverService;

  public DayOfWeekResolverAction(@Autowired DayOfWeekResolverForm dayOfWeekResolverForm,
                                 @Autowired DayOfWeekResolverService dayOfWeekResolverService)
  {
    this.dayOfWeekResolverForm = dayOfWeekResolverForm;
    this.dayOfWeekResolverService = dayOfWeekResolverService;
  }

  public void determineDayOfWeek()
  {
    validateParameters(dayOfWeekResolverForm);

    int year = dayOfWeekResolverForm.getYear();
    int month = dayOfWeekResolverForm.getMonth();
    int dayOfMonth = dayOfWeekResolverForm.getDayOfMonth();

    String dayOfWeekName = dayOfWeekResolverService.determineDayOfWeek(year, month, dayOfMonth);
    dayOfWeekResolverForm.setDayOfWeek(dayOfWeekName);
  }

  private void validateParameters(DayOfWeekResolverForm dayOfWeekResolverForm)
  {
    // logic to validate the parameters, if not valid, throw a runtime exception
  }
}

[/code]

Now that we have an action, form and service then we will move on to create our web page.
<h3>Creating a JSF page</h3>
In our Maven project, we will need to create a new directory, <strong>webapp/WEB-INF</strong>, as shown below, which will carry our JSF web pages.

<a href="https://tsepomaleka.com/wp-content/uploads/2019/04/add-new-folders.png"><img class="aligncenter size-full wp-image-637" src="https://tsepomaleka.com/wp-content/uploads/2019/04/add-new-folders.png" alt="" width="646" height="563" /></a>Under <strong>webapp</strong> directory in your Maven project, create a new JSF page, and name it, <strong>resolve-day-of-week.xhtml</strong>:

[code language="xhtml" light="true"]

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:h="http://xmlns.jcp.org/jsf/html">

<h:head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="description" content="Resolves a date to a day of the week"/>
    <meta name="author" content="Tsepo Maleka"/>

    <title>Day of Week Resolver</title>

    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootswatch/4.3.1/cosmo/bootstrap.min.css"/>

</h:head>
<h:body>

</h:body>

</html>

[/code]

Just a few things to note:
<ul>
 	<li>The DOCTYPE should adhere to HTML5 standards to be able to use the latest HTML5 tags and attributes</li>
 	<li>You can choose to use Twitter Bootstrap or not - it was just a choice really for me. So you may not need the stylesheets and the scripts.</li>
 	<li>The meta tags in the head HTML tag are mandatory, so replace with your own relevant details where applicable.</li>
</ul>
Now we will modify the JSF page to add a form, with fields to capture the day of the month, the month and the year:

[code language="xhtml" light="true"]

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:h="http://xmlns.jcp.org/jsf/html">

<h:head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="description" content="Resolves a date to a day of the week"/>
    <meta name="author" content="Tsepo Maleka"/>

    <title>Day of Week Resolver</title>

    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootswatch/4.3.1/cosmo/bootstrap.min.css"/>

</h:head>
<h:body>




<div class="container">



Enter the date you want to resolve its day of the week:


        <h:form id="dayOfWeekResolverForm">

            <h:panelGroup layout="block" rendered="#{not empty dayOfWeekResolverForm.dayOfWeek}">

<div class="row">

<div class="col-md-6">
                        The day of the week is:
                        <strong>
                            <h:outputLabel value="#{dayOfWeekResolverForm.dayOfWeek}" />
                        </strong>
                    </div>

                </div>




            </h:panelGroup>


<div class="form-group">
                <label for="dayOfMonthField">Day of Month:</label>
                <h:inputText id="dayOfMonthField" styleClass="form-control" autocomplete="off" maxlength="2" value="#{dayOfWeekResolverForm.dayOfMonth}" />
            </div>


<div class="form-group">
                <label for="monthField">Month:</label>
                <h:inputText id="monthField" styleClass="form-control" autocomplete="off" maxlength="2" value="#{dayOfWeekResolverForm.month}" />
            </div>


<div class="form-group">
                <label for="yearField">Year:</label>
                <h:inputText id="yearField" styleClass="form-control" autocomplete="off" maxlength="4" value="#{dayOfWeekResolverForm.year}" />
            </div>

            <h:commandButton type="submit" value="Resolve Day of Week" styleClass="btn btn-primary" action="#{dayOfWeekResolverAction.determineDayOfWeek}" />

        </h:form>

    </div>
</h:body>

</html>

[/code]

&nbsp;